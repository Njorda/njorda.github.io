<!doctype html><html><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Njord tech blog | Home</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:image" content><link rel=alternate type=application/rss+xml href=https://njorda.github.io/index.xml title="Njord tech blog"><meta property="og:title" content="Njord tech blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://njorda.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Njord tech blog"><meta name=twitter:description content><link href=https://njorda.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://njorda.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://njorda.github.io/>Njord tech blog</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/2023/03/23/storing-kubeflow-pipeline-templates-gcp-artifact-registry/>Storing Kubeflow Pipeline Templates in GCP Artifact Registry</a></h1><time>Mar 23, 2023</time><br><div class=description>In this blog post, we will discuss how to store Kubeflow Pipeline templates in GCP Artifact Registry, enabling reusability and version control for your pipelines. Using Artifact Registry over Cloud Storage simplifies version control and allows for easier collaboration between single or multiple users.
The Kubeflow Pipelines SDK registry client is a new client interface that you can use with a compatible registry server (ensure you are using the correct KFP version), such as Artifact Registry, for version control of your Kubeflow Pipelines (KFP) templates.&mldr;</div><a class=readmore href=/2023/03/23/storing-kubeflow-pipeline-templates-gcp-artifact-registry/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/03/21/kubeflow-pipelines/>Running a kubeflow pipeline on google vertex</a></h1><time>Mar 21, 2023</time><br><div class=description>This blog post will go over how to build and run your very first kubeflow pipeline (kfp). In short, Kubeflow Pipelines is a platform for building and deploying portable, scalable machine learning (ML) workflows based on Docker containers.
There are a lot of possibilities to run the pipelines, but in this series, we will use gcp vertex pipelines. Vertex will be the runner, but the pipelines will follow the kubeflow conventions meaning you can run them on whatever platform at hand or host kubeflow on your own Kubernetes cluster.&mldr;</div><a class=readmore href=/2023/03/21/kubeflow-pipelines/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/03/20/vs-code-dev-container-gcp-credentials/>Configuring Your Local Dev Container with GCP Default Credentials</a></h1><time>Mar 20, 2023</time><br><div class=description>This blog post provides a step-by-step guide for setting up your VS Code dev container to work with Google Cloud Platform (GCP) services and APIs by configuring default GCP credentials. By authenticating your application with your GCP credentials, you can access the necessary resources without requiring additional authentication steps, saving time and streamlining your development workflow.
Configuring Default GCP Credentials To use default credentials with GCP, you can follow the steps below:&mldr;</div><a class=readmore href=/2023/03/20/vs-code-dev-container-gcp-credentials/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/03/18/dev-containers/>Supercharge Your Development Workflow with VS Code Dev Containers</a></h1><time>Mar 18, 2023</time><br><div class=description>VS docker Dev Container Are you tired of dealing with messy, inconsistent development environments that slow down your workflow? Look no further than VS Code dev containers, a powerful feature in Visual Studio Code that can streamline your development process and improve consistency across different environments.
In this post, we&rsquo;ll dive into what dev containers are and how you can use them to supercharge your development workflow. We&rsquo;ll also walk through how to set up a dev container for a Python environment and you will get an understsnding how easy it is to get started.&mldr;</div><a class=readmore href=/2023/03/18/dev-containers/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/03/11/postgress_extention_using_chatgpt3/>Postgress extention using ChatGPT3</a></h1><time>Mar 11, 2023</time><br><div class=description>This blog post will dive into building postgres extensions using pgx in rust. In order to do something existing we will ride the hype curve and integrate ChatGPT3 into postgres.
TLDR: repo
Setup First step is to set up pgx:
$ cargo install --locked cargo-pgx $ cargo pgx init We will then create a new create using:
$ cargo pgx new my_extension $ cd my_extension Which should give you something like:&mldr;</div><a class=readmore href=/2023/03/11/postgress_extention_using_chatgpt3/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/03/01/go_memory_arena/>Go memory arena</a></h1><time>Mar 1, 2023</time><br><div class=description>As part of the go 1.20 release memory areas where introduced to the standard lib but not mentioned in the release notes but is still being discussed as of 2023-03-02 here. Memory arenas allow users to allocate memory and are described by the docs as:
The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely. The purpose of this functionality is to improve efficiency: manually freeing memory before a garbage collection delays that cycle.&mldr;</div><a class=readmore href=/2023/03/01/go_memory_arena/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/02/25/triton_shared_memory/>Triton shared memory and pinned memory</a></h1><time>Feb 25, 2023</time><br><div class=description>This blog post will go in to depth how to use shared memory together with nvidia triton and pinned memory for model serving. This will continue to build further on the other blog posts related to triton. First we will focuse on shared memory and then move over to also look in to pinned memory and why it matters.
Shared memory In the triton examples(python) shared memory is often abbreviated as shm.&mldr;</div><a class=readmore href=/2023/02/25/triton_shared_memory/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/02/06/hugo-duckdb/>Duckdb with hugo</a></h1><time>Feb 8, 2023</time><br><div class=description>Current hack to just get the stuff working.&mldr;</div><a class=readmore href=/2023/02/06/hugo-duckdb/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/02/08/Profile-guided_inlining_optimization/>Go compiler optimizations</a></h1><time>Feb 8, 2023</time><br><div class=description>This is based upon the new feature released in go v1.20 where the compiler can optimize using a pprof file.
In order to run the pprof we will use flags:
flag.Parse() if *cpuprofile != "" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } more info can be found here.
In order to run the profiling use the following command:
go run main.go -cpuprofile=prof.&mldr;</div><a class=readmore href=/2023/02/08/Profile-guided_inlining_optimization/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/2023/02/06/hugo-with-python-rshiny/>Shinylive app with hugo</a></h1><time>Feb 6, 2023</time><br><div class=description>Shinylive app with hugo This blog post is based upon RamiKrispin/shinylive where we will take a look in to using Shiny with python and leveraging WebAssembly to let it run in the browser with out a backend. This allows for interactive static webpages.
In order to add the a shiny app it needs to be deployed, in this case that is handled through github pages and lives within https://github.com/NikeNano/shinylive. The second step is to add the iframe:&mldr;</div><a class=readmore href=/2023/02/06/hugo-with-python-rshiny/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"></span><span class="page-item page-next"><a href=/page/2/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>