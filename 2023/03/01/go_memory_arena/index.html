<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go memory arena - Njord tech blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="As part of the go 1.20 release memory areas where introduced to the standard lib but not mentioned in the release notes but is still being discussed as of 2023-03-02 here. Memory arenas allow users to allocate memory and are described by the docs as:
The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely. The purpose of this functionality is to improve efficiency: manually freeing memory before a garbage collection delays that cycle."><meta property="og:image" content><meta property="og:title" content="Go memory arena"><meta property="og:description" content="As part of the go 1.20 release memory areas where introduced to the standard lib but not mentioned in the release notes but is still being discussed as of 2023-03-02 here. Memory arenas allow users to allocate memory and are described by the docs as:
The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely. The purpose of this functionality is to improve efficiency: manually freeing memory before a garbage collection delays that cycle."><meta property="og:type" content="article"><meta property="og:url" content="https://www.njordy.com/2023/03/01/go_memory_arena/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go memory arena"><meta name=twitter:description content="As part of the go 1.20 release memory areas where introduced to the standard lib but not mentioned in the release notes but is still being discussed as of 2023-03-02 here. Memory arenas allow users to allocate memory and are described by the docs as:
The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely. The purpose of this functionality is to improve efficiency: manually freeing memory before a garbage collection delays that cycle."><link href=https://www.njordy.com/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.njordy.com/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://www.njordy.com/>Njord tech blog</a></div><nav><a href=../../../../>Home</a>
<a href=../../../../posts>All posts</a>
<a href=../../../../about>About</a></nav></header><main><article><div class=title><h1 class=title>Go memory arena</h1><div class=meta>Posted on Mar 1, 2023</div></div><section class=body><p>As part of the go 1.20 release <a href=https://go.dev/src/arena/arena.go>memory areas</a> where introduced to the standard lib but not mentioned in the <a href=https://go.dev/doc/go1.20>release notes</a> but is still being discussed as of 2023-03-02 <a href=https://github.com/golang/go/issues/51317>here</a>. Memory arenas allow users to allocate memory and are described by the docs as:</p><blockquote><p>The arena package provides the ability to allocate memory for a collection
of Go values and free that space manually all at once, safely. The purpose
of this functionality is to improve efficiency: manually freeing memory
before a garbage collection delays that cycle. Less frequent cycles means
the CPU cost of the garbage collector is incurred less frequently.</p></blockquote><p>But why would one do this? Go is garbage collected so why is the need to get rid of that functionality for certain objects of your code? Garbage Collection(GC) comes with a certain over head. Depending upon your program this could be a substantial cost in terms of CPU which memory arenas could help reduce at the cost or manually managing the memory. The <code>memory arenas</code> as en example of <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>region based memory</a>. Where a region( aka area) can be reallocated or deallocated all at once. Often region and areas are implemented such that all objects in a area are allocated in a <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>single contiguous range</a> of memory(same as stack frames). It should be noted that areas should NEVER be accessed by multiple <code>goroutines</code>.</p><p>Areas are only avilable in go 1.20 when <code>experimental</code> is used.</p><pre tabindex=0><code>GOEXPERIMENT=arenas go run main.go
</code></pre><pre tabindex=0><code>import &#34;arena&#34;


func process() {
	// Create an arena
	mem := arena.NewArena()
	// Free the arena in the end.
	defer mem.Free()

	// Or a slice with length and capacity.
	slice := arena.MakeSlice[T](mem, 100, 200)
}
</code></pre><p>if a slice out grows the capacity it will be moved to the <code>heap</code> if not reallocated.</p><p>I will play around and try to see if I can validate the performance boost that <a href=https://github.com/golang/go/issues/51317>google reported of 15%</a></p></section><div class=post-tags></div></article></main><footer><div style=display:flex></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>