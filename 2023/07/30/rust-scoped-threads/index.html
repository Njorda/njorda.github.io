<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Rust: Scoped threads - easier multithreading - Njord tech blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The current development in CPU design is going towards large amount of cores rather than faster cores and thus writing parallel code becomes more important in order to utilize the full potential (Concurrency is not Parallelism). In this blog post we will dive into scoped threads, what it is and what is the difference between threads in rust in general. First of all only use threads if you need the speed up, introducing threads to a program adds complexity which both makes the program harder to maintain but if not done correct also slower to run(due to communications between threads and scheduling)."><meta property="og:image" content><meta property="og:title" content="Rust: Scoped threads - easier multithreading"><meta property="og:description" content="The current development in CPU design is going towards large amount of cores rather than faster cores and thus writing parallel code becomes more important in order to utilize the full potential (Concurrency is not Parallelism). In this blog post we will dive into scoped threads, what it is and what is the difference between threads in rust in general. First of all only use threads if you need the speed up, introducing threads to a program adds complexity which both makes the program harder to maintain but if not done correct also slower to run(due to communications between threads and scheduling)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.njordy.com/2023/07/30/rust-scoped-threads/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust: Scoped threads - easier multithreading"><meta name=twitter:description content="The current development in CPU design is going towards large amount of cores rather than faster cores and thus writing parallel code becomes more important in order to utilize the full potential (Concurrency is not Parallelism). In this blog post we will dive into scoped threads, what it is and what is the difference between threads in rust in general. First of all only use threads if you need the speed up, introducing threads to a program adds complexity which both makes the program harder to maintain but if not done correct also slower to run(due to communications between threads and scheduling)."><link href=https://www.njordy.com/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.njordy.com/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://www.njordy.com/>Njord tech blog</a></div><nav><a href=../../../../>Home</a>
<a href=../../../../posts>All posts</a>
<a href=../../../../about>About</a></nav></header><main><article><div class=title><h1 class=title>Rust: Scoped threads - easier multithreading</h1><div class=meta>Posted on Jul 30, 2023</div></div><section class=body><p>The current development in CPU design is going towards large amount of cores rather than faster cores and thus writing parallel code becomes more important in order to utilize the full potential (<a href="https://www.youtube.com/watch?v=oV9rvDllKEg">Concurrency is not Parallelism</a>). In this blog post we will dive into scoped threads, what it is and what is the difference between threads in rust in general. First of all only use threads if you need the speed up, introducing threads to a program adds complexity which both makes the program harder to maintain but if not done correct also slower to run(due to communications between threads and scheduling).</p><p>Assuming threads is the way to go in your rust program the next step is to understand what threads are in rust. Compare to <code>go</code> which has the concept of <code>goroutines</code> which is a layer on top of operatins system threads(where multiple go routines are multiplexed on to a single os thread, super cool concept that we will dive deeper in to in a separate blog post) rust kicks of a os thread per thread created with the <code>use std::thread;</code> create. Is should thus be noted that for smaller tasks this will not be worth to do, only for larger chunks of work will this result in a speed up of the the program.</p><p>To start a thread in rust(example from <a href=https://doc.rust-lang.org/book/ch16-01-threads.html>the book</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    thread::spawn(<span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;hi number {} from the spawned thread!&#34;</span>, i);
</span></span><span style=display:flex><span>            thread::sleep(Duration::from_millis(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;hi number {} from the main thread!&#34;</span>, i);
</span></span><span style=display:flex><span>        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hi number <span style=color:#ae81ff>1</span> from the main thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>1</span> from the spawned thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>2</span> from the main thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>2</span> from the spawned thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>3</span> from the main thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>3</span> from the spawned thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>4</span> from the main thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>4</span> from the spawned thread!
</span></span><span style=display:flex><span>hi number <span style=color:#ae81ff>5</span> from the spawned thread!
</span></span></code></pre></div><p>However it should be noted that there is nothing in here that guarantees that the main thread will wait for the spawned once. This could be handled a <code>handle</code> could be used, more info <a href=https://doc.rust-lang.org/book/ch16-01-threads.html>here</a>.</p><p>So to the point of scoped threads what is the difference and why does it matter? But maybe first of all what is scope in rust? Shortly variable scope can be described as the part of the code where a variable can be accessed. Rust implements what is known as <a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization>Resource acquisition is initialization</a> or just RAII for short, which means that variable in Rust not only hold the data, but also owns the resource. The main advantage of RAII is that it encapsulates of resources by tying the resource lifetime to a stack variable. When a variable goes out of scope(not accessable any longer in the program) the resources are freed and thus as long as we avoid leaking variable we avoid leaking resources. Since variables are connected to the release of resources variables can only have one owner. Assignments and passing function arguments by value results in transfer of the ownership in rust this is known as a <a href=https://doc.rust-lang.org/std/keyword.move.html>move</a>(which is also a key word for moving ownership of a variable).</p><p>A simple example on how to start threads using a handle is(from found <a href=https://rust-lang.github.io/rfcs/3151-scoped-threads.html>here</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> greeting <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello world!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;thread #1 says: {}&#34;</span>, greeting);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>handle.join().unwrap();
</span></span></code></pre></div><p>in the example above the variable <code>greeting</code> is moved, notice the move key word in the thread spawn. If we like to do the same but from two threads we would have to clone it(example found <a href=https://rust-lang.github.io/rfcs/3151-scoped-threads.html>here</a>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> greeting <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello world!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> handle1 <span style=color:#f92672>=</span> thread::spawn({
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> greeting <span style=color:#f92672>=</span> greeting.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;thread #1 says: {}&#34;</span>, greeting);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> handle2 <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;thread #2 says: {}&#34;</span>, greeting);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>handle1.join().unwrap();
</span></span><span style=display:flex><span>handle2.join().unwrap();
</span></span></code></pre></div><p><code>thread</code> requires a <code>'static</code> life time since it might out live the main thread and thus borrowing is not allowed. This is where scoped threads come to the rescue. Scoped threads allow us to open a scope where threads spawned within will also die within the scope. Thus we can gurantee at compile time that the variables will outlive the spawned threads and thus we can borrow without problems.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> greeting <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;Hello world!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>thread::scope(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>    s.spawn(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;thread #1 says: {}&#34;</span>, greeting);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s.spawn(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;thread #2 says: {}&#34;</span>, greeting);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Another advantage of scoped threads is also that we are guaranteed to wait for both the spawned threads to finish before the main. Scoped threads has the advantage or not requiring cloning and also makes the code easier to read.</p></section><div class=post-tags></div></article></main><footer><div style=display:flex></div><div class=footer-info>2024 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>