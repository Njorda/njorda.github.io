<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Rust Foreign data wrappers for postgres - Njord tech blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Background In this blog post we will try to implement a foreign data wrappers for postgres in rust. We will build on top of pgx in order to not have to build everything from the ground. But first of what is a foreign data wrapper? From the postgres docs:
A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it."><meta property="og:image" content><meta property="og:title" content="Rust Foreign data wrappers for postgres "><meta property="og:description" content="Background In this blog post we will try to implement a foreign data wrappers for postgres in rust. We will build on top of pgx in order to not have to build everything from the ground. But first of what is a foreign data wrapper? From the postgres docs:
A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it."><meta property="og:type" content="article"><meta property="og:url" content="https://www.njordy.com/2023/06/12/rust-foreign-data-wrappers-postgres-rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Foreign data wrappers for postgres "><meta name=twitter:description content="Background In this blog post we will try to implement a foreign data wrappers for postgres in rust. We will build on top of pgx in order to not have to build everything from the ground. But first of what is a foreign data wrapper? From the postgres docs:
A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it."><link href=https://www.njordy.com/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.njordy.com/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://www.njordy.com/>Njord tech blog</a></div><nav><a href=../../../../>Home</a>
<a href=../../../../posts>All posts</a>
<a href=../../../../about>About</a></nav></header><main><article><div class=title><h1 class=title>Rust Foreign data wrappers for postgres</h1><div class=meta>Posted on Jun 12, 2023</div></div><section class=body><h1 id=background>Background</h1><p>In this blog post we will try to implement a foreign data wrappers for postgres in rust. We will build on top of <a href=https://github.com/tcdi/pgx>pgx</a> in order to not have to build everything from the ground. But first of what is a foreign data wrapper? From the <a href="https://www.postgresql.org/docs/current/ddl-foreign-data.html#:~:text=A%20foreign%20data%20wrapper%20is,and%20obtaining%20data%20from%20it.">postgres docs</a>:</p><blockquote><p>A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it.</p></blockquote><p>So to say it simple, a foreign data wrapper add functionality to access a external data source. This blog post will be based upon a implementation for CMU 15-721(not taking the course just doing it for fun), repo <a href=https://github.com/Njorda/db721_fdw>here</a>.</p><h1 id=awesome-resources>Awesome Resources</h1><p><a href=https://www.dolthub.com/blog/2022-01-26-creating-a-postgres-foreign-data-wrapper/>Really good blog post that heavily inspired this one, FDW using c</a>
<a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>Postgres docs, great to add but not enough on its own for me</a>
<a href=https://github.com/supabase/wrappers>Superbase wrappers, great to have a implementation to compare with and see the correct pgxr syntax</a>
<a href=https://docs.rs/sqlx/latest/sqlx/postgres/types/index.html>Mapping of data types between rust and postgres</a></p><h1 id=how-does-it-really-work>How does it really work.</h1><p>The first step of a FDW is the <code>control</code> file which describes the postgres extensions and metadata about it. Using <a href=https://github.com/tcdi/pgrx>pgrx</a> this is created automatically. This will be loaded when we run <code>CREATE EXTENSION db721_fdw</code>. A foreign data wrapper in postgres needs to have two things:</p><ul><li>A <code>handler</code>, which will return a struct of function pointers that will implement the FDW api. These function pointers will then be used by postgres when executing the FDW.</li><li>A <code>validator</code>, optional wich will be called with the options for validation.</li></ul><p>The first step in understanding how the a FDW works is to look at the struct returned by the <code>handler</code>, the definition can be found <a href=https://github.com/postgres/postgres/blob/REL_14_STABLE/src/include/foreign/fdwapi.h#L194>here</a>. However most will not have to be implemented. We will in this case focuse on the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>fdwroutine.GetForeignRelSize <span style=color:#f92672>=</span> Some(hello_get_foreign_rel_size);
</span></span><span style=display:flex><span>fdwroutine.GetForeignPaths <span style=color:#f92672>=</span> Some(hello_get_foreign_paths);
</span></span><span style=display:flex><span>fdwroutine.GetForeignPlan <span style=color:#f92672>=</span> Some(hello_get_foreign_plan);
</span></span><span style=display:flex><span>fdwroutine.ExplainForeignScan <span style=color:#f92672>=</span> Some(hello_explain_foreign_scan);
</span></span><span style=display:flex><span>fdwroutine.BeginForeignScan <span style=color:#f92672>=</span> Some(hello_begin_foreign_scan);
</span></span><span style=display:flex><span>fdwroutine.IterateForeignScan <span style=color:#f92672>=</span> Some(hello_iterate_foreign_scan);
</span></span><span style=display:flex><span>fdwroutine.ReScanForeignScan <span style=color:#f92672>=</span> Some(hello_re_scan_foreign_scan);
</span></span><span style=display:flex><span>fdwroutine.EndForeignScan <span style=color:#f92672>=</span> Some(hello_end_foreign_scan);
</span></span><span style=display:flex><span>fdwroutine.AnalyzeForeignTable <span style=color:#f92672>=</span> Some(hello_analyze_foreign_table);
</span></span></code></pre></div><p>the next part of the implementation will be broken up based upon the <a href=https://www.postgresql.org/docs/14/query-path.html>path of a query</a> in postgres. The steps a query has to pass to obtain results in postgres(FDW also obey to this):</p><ol><li>Connection from an application program to the Postgres server. A query is transmitted to the sever and waits for a results to be sent back by the server.</li><li>Syntax is checked byt the parser and creates a query tree.</li><li>The rewrite system looks for rules to apply to the query tree. One examples is this it the realization of views. A query against a view is converted to a query against the based table based upon the view definition.</li><li>The planner/Optimizer takes the query tree and creates a query plan base upon which the execution will be made.</li><li>The executor recursively goes through the plan tree and retrieve the rows represented by the plan.</li></ol><h3 id=path-and-plans>Path and plans</h3><p>The planing phase for a FDW consists of <code>GetForeignRelSize</code>, <code>GetForeignPaths</code> and <code>GetForeignPlan</code> and is executed in that order. The purpose of each step is the following:</p><ul><li><a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>GetForeignRelSize</a> should update the baserel rows and potentially also width. This will later be used by the optimizer. If not the correct values are set it could lead to potential miss optimization. This is also the place where we will handle the <a href=https://www.postgresql.org/docs/current/postgres-fdw.html#id-1.11.7.47.11>FDW options</a>. In order to send information to the next step of the planing we will store the information inside <code>ForeignScan node</code> using the <code>void *fdw_private</code> that is provided by postgres. <code>fdw_private</code> will not be touched by anything else and is it is free to store anything of interest within it.</li><li><a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>GetForeignPaths</a> describes the paths to access the data. In our case there will only be one. Each paths should include a cost estimate. This will be used by the optimizer to find the optimal path. This is set on the <code>baserel->pathlist</code>.</li><li><a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>GetForeignPlan</a> ir responsible for creating a <code>ForeignScan *</code> for the given <code>ForeignPath *</code>. As input the optimizer has selected the best access path(in our case there will only be one). Here we will also be able to pass information on to the next group of steps of the processing, [Begin, Iterate, End](# Begin, Iterate, End) where we will execute the plan, using the <code>void *fdw_state</code>. However <code>void *fdw_state</code> is a list so if the information from <code>void *fdw_private</code> should be propagate id needs to be reformated.</li></ul><h3 id=begin-iterate-end>Begin, Iterate, End</h3><p>When a plan is created the next step is to execute on the plan, this happens in three steps</p><ul><li><a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>BeginForeignScan</a> should do any initialization that is needed before the scan. Information from the planing state can be accessed through <code>ForeignScanState</code> and the underlying <code>ForeignScan</code> which contains <code>fdw_private</code> which is provided through the previous planing and specifically <code>GetForeignPlan</code>. To pass information further the <code>fdw_state</code> on the <code>ForeignScanState</code> can be used.</li><li><a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>IterateForeignScan</a> should fetch one row(only), if all data is returned NULL should be returned marking the end. <code>ScanTupleSlot</code> should be used for the data return. Either a physical or virtual tuple should be returned. The rows returned must match the table definition of the FDW table.
-<a href=https://www.postgresql.org/docs/9.2/fdw-callbacks.html>EndForeignScan</a> end the scan and release resources. It is normally not important to release palloc&rsquo;d memory, but for example open files and connections to remote servers should be cleaned up.</li></ul><h3 id=fdw-options>FDW options</h3><p>When creating a FDW table there is a possibility to add <a href=https://www.postgresql.org/docs/current/postgres-fdw.html#id-1.11.7.47.11>some options</a>. This will be utalised in our case to know where the file where the information is stored.</p><h3 id=walk-over-the-implementation>Walk over the implementation.</h3><p>The first step in building the FDW is to create the handler function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pg_extern]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>db721_fdw_handler</span>() -&gt; <span style=color:#a6e22e>fdw_handler</span> {
</span></span><span style=display:flex><span>    debug1<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;HelloFdw: hello_fdw_handler&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fdwroutine <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        pgrx::PgBox::<span style=color:#f92672>&lt;</span>pg_sys::FdwRoutine<span style=color:#f92672>&gt;</span>::alloc_node(pg_sys::NodeTag_T_FdwRoutine);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set callback functions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fdwroutine.GetForeignRelSize <span style=color:#f92672>=</span> Some(get_foreign_rel_size);
</span></span><span style=display:flex><span>    fdwroutine.GetForeignPaths <span style=color:#f92672>=</span> Some(get_foreign_paths);
</span></span><span style=display:flex><span>    fdwroutine.GetForeignPlan <span style=color:#f92672>=</span> Some(get_foreign_plan);
</span></span><span style=display:flex><span>    fdwroutine.ExplainForeignScan <span style=color:#f92672>=</span> Some(explain_foreign_scan);
</span></span><span style=display:flex><span>    fdwroutine.BeginForeignScan <span style=color:#f92672>=</span> Some(begin_foreign_scan);
</span></span><span style=display:flex><span>    fdwroutine.IterateForeignScan <span style=color:#f92672>=</span> Some(iterate_foreign_scan);
</span></span><span style=display:flex><span>    fdwroutine.ReScanForeignScan <span style=color:#f92672>=</span> Some(re_scan_foreign_scan);
</span></span><span style=display:flex><span>    fdwroutine.EndForeignScan <span style=color:#f92672>=</span> Some(end_foreign_scan);
</span></span><span style=display:flex><span>    fdwroutine.AnalyzeForeignTable <span style=color:#f92672>=</span> Some(analyze_foreign_table);
</span></span><span style=display:flex><span>    fdwroutine
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we can notice it is marked with <code>#[pg_extern]</code> which is a attribute marco from the <code>pgxr</code> crate for wrapping rust functions with boiler plate for defining and calling conventions between Postgres and Rust.</p><p>The function <code>fdw_handler</code> struct has the postgres hooks that are <code>options</code> with the defualt is None(Null in Postgres). The next step is to implement these functions one by one. Going down this rabbit hole myself I hope to cover the things I struggled with, both in terms of just getting it to work but also small key points of how postgres works.</p><p>Going over the implementation in the order of execution the first step is to implement the <code>GetForeignRelSize</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_foreign_rel_size</span>(
</span></span><span style=display:flex><span>    root: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::PlannerInfo,
</span></span><span style=display:flex><span>    baserel: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::RelOptInfo,
</span></span><span style=display:flex><span>    foreigntableid: <span style=color:#a6e22e>pg_sys</span>::Oid,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As mentioned above, the key goal for <code>GetForeignRelSize</code> is to set the nbr of rows(and potentially width) for the optimizer as well as handle the options. However in this first optimization(later blog post will dive down and try to optimize it). We will just set the nbr of rows to 10(arbitrary low nbr).</p><p>Postgres offers the possibility to send information between the hooks using the <code>fdw_private</code>. We will use this to store the information, during <code>GetForeignRelSize</code> we will extract the following and store:</p><ul><li>selected columns</li><li>conditions of the query</li><li>options</li></ul><p>The first step is to create the state where we can store the information using<code>PgBox</code> which is a heap-allocated pointer that is allocated by Postgres&rsquo;s memory allocation function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> pgrx::PgBox::<span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span>::alloc0();
</span></span></code></pre></div><p>The state is a rust struct of the <code>FdwState</code> which is defined for our use case as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FdwState</span> {
</span></span><span style=display:flex><span>    rownum: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    opts: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    metadata: Option<span style=color:#f92672>&lt;</span>Metadata<span style=color:#f92672>&gt;</span>, 
</span></span><span style=display:flex><span>    filters: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, Filter<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    nulls: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    tmp_ctx: <span style=color:#a6e22e>PgMemoryContexts</span>,
</span></span><span style=display:flex><span>    cols: Vec<span style=color:#f92672>&lt;</span>ColumnMetadada<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    tuples: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Cell<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    natts: <span style=color:#66d9ef>usize</span>, 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Some of these fields might not make sense now but will(hopefully) when we go over the different part of the FDW implementation. You are free to add anything of interest or needed for your wrapper. The extracted values(selected columns, conditions, options) are stored in the <code>state</code> as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    state.cols <span style=color:#f92672>=</span> cols;
</span></span><span style=display:flex><span>    state.opts <span style=color:#f92672>=</span> ret; 
</span></span><span style=display:flex><span>    state.filters <span style=color:#f92672>=</span> filters;
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>baserel).fdw_private <span style=color:#f92672>=</span> state.into_pg() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> std::ffi::c_void;
</span></span></code></pre></div><p>When done with the <code>GetForeignRelSize</code> the next step is to continue with the <code>GetForeignPaths</code>. We will not spend to much focuse on <code>GetForeignPaths</code> since we only have one execution path and thus will just return one plan. Similar for <code>GetForeignPlan</code> we will just generate one plan. If several plans where available the optimizer would select the one with the lowest cost, however since we only have one it does not matter to much. <code>ExplainForeignScan</code> is also a dummy implementation that is left for future work. The next step of importance is the <code>BeginForeignScan</code> which should perform any initialization needed before the scan can start, but not start executing the actual scan(this should be done during the first call to the next step, <code>IterateForeignScan</code>). One of the key things we will do during the <code>BeginForeignScan</code> is to forward the information from the planing steps to the execution steps. Where the information we set in <code>GetForeignRelSize</code> in <code>fdw_private</code> is extracted from the <code>ForeignScanState</code> and the actual plan to a new <code>PgBox</code> that is stored in side the <code>fdw_state</code>. This actually took some time for me to get my head around mostly due to mixing up the <code>fdw_private</code> for the plan with the <code>fdw_state</code> of the <code>ForeignScan</code>. However it is just postgres internal how information is passed between the different steps, and we will use the same data type(<code>FdwState</code>) to hold the information. The key part of the implementation is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[pg_guard]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>begin_foreign_scan</span>(
</span></span><span style=display:flex><span>    node: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::ForeignScanState,
</span></span><span style=display:flex><span>    eflags: ::std::os::raw::c_int,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We get the state from the plan and convert it to.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// First we can get the scan state. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> scan_state <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>node).ss;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> plan <span style=color:#f92672>=</span> scan_state.ps.plan <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::ForeignScan;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list <span style=color:#f92672>=</span> PgList::<span style=color:#f92672>&lt;</span>pg_sys::Const<span style=color:#f92672>&gt;</span>::from_pg((<span style=color:#f92672>*</span>plan).fdw_private );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cst <span style=color:#f92672>=</span> list.head().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>i64</span>::from_datum((<span style=color:#f92672>*</span>cst).constvalue, (<span style=color:#f92672>*</span>cst).constisnull).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state:<span style=color:#a6e22e>PgBox</span>::<span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> PgBox::from_pg(ptr <span style=color:#66d9ef>as</span> _);
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Save the state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    (<span style=color:#f92672>*</span>node).fdw_state <span style=color:#f92672>=</span> state.into_pg() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> std::ffi::c_void;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The most important part of the FDW and the meat of the implementation(at least for this implementation) is the <code>IterateForeignScan</code> where we will read the actual data. <code>IterateForeignScan</code> is invocated each until a null row is returned indicating that all rows are fetched. This is handled by checking the current row number which is increase for each iteration, checking with the total nbr of rows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pg_guard]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iterate_foreign_scan</span>(
</span></span><span style=display:flex><span>    node: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::ForeignScanState,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::TupleTableSlot {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state: <span style=color:#a6e22e>PgBox</span><span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> PgBox::<span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span>::from_pg((<span style=color:#f92672>*</span>node).fdw_state <span style=color:#66d9ef>as</span> _);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>state).rownum <span style=color:#f92672>&gt;=</span> (<span style=color:#f92672>*</span>state).tuples.len()   { <span style=color:#75715e>// https://www.highgo.ca/2021/09/03/implement-foreign-scan-with-fdw-interface-api/
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>slot).tts_ops).clear.expect(<span style=color:#e6db74>&#34;missing&#34;</span>)(slot);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> slot;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>. The first invocation will in our implementation fetch all the data and store it returning a new row for each iteration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pg_guard]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iterate_foreign_scan</span>(
</span></span><span style=display:flex><span>    node: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::ForeignScanState,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::TupleTableSlot {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state: <span style=color:#a6e22e>PgBox</span><span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> PgBox::<span style=color:#f92672>&lt;</span>FdwState<span style=color:#f92672>&gt;</span>::from_pg((<span style=color:#f92672>*</span>node).fdw_state <span style=color:#66d9ef>as</span> _);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>state).rownum <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> meta <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>state).metadata.clone().unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> filters <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>state).filters;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> data <span style=color:#f92672>=</span> meta.fetch_data(filters.clone(), <span style=color:#f92672>&amp;</span>state.cols);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (values, mask) <span style=color:#f92672>=</span> meta.tuples(<span style=color:#f92672>&amp;</span>data, (<span style=color:#f92672>*</span>state).cols.clone(), state.natts);
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>state).tuples <span style=color:#f92672>=</span> values;
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>state).nulls <span style=color:#f92672>=</span> mask;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As describe a new row is returned for each invocation, null values are marked using the <code>tts_isnull</code> state on the <code>TupleTableSlot</code> that is returned.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pg_guard]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>iterate_foreign_scan</span>(
</span></span><span style=display:flex><span>    node: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::ForeignScanState,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> pg_sys::TupleTableSlot {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> slot <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>node).ss.ss_ScanTupleSlot;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> idx <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>state).rownum.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> row:Vec<span style=color:#f92672>&lt;</span>Datum<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>state).tuples[idx].iter().map(<span style=color:#f92672>|</span>val<span style=color:#f92672>|</span> val.clone().into_datum().unwrap()).collect();
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>slot).tts_values <span style=color:#f92672>=</span> row.as_mut_ptr();
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>slot).tts_isnull <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>state).nulls[idx].as_mut_ptr();
</span></span><span style=display:flex><span>    pg_sys::ExecStoreVirtualTuple(slot);
</span></span><span style=display:flex><span>    state.rownum <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    old_ctx.set_as_current();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> slot
</span></span></code></pre></div><p>The main logic in reading the data comes down to parsing the data format, however this is not relevant for implementing a FDW in general and we will not deep dive in to this in this blog post, however there will be a follow up where we try to optimize the code and will take a closer look. <code>ReScanForeignScan</code> restart the scan from the beginning and we thus need to se the row nbr to 0 again. <code>AnalyzeForeignTable</code> is set to just return false since we will not return any statistics for the FDW at this stage(could also be left to false.)</p><h1 id=whats-next>Whats next</h1><p>In a follow up blog post we will continue working on the FDW in order to optimize it and see if we can make it go fast! Happy coding and good luck implementing your FDW in rust!</p></section><div class=post-tags></div></article></main><footer><div style=display:flex></div><div class=footer-info>2023 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>